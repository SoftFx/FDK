namespace SoftFX.Lrp
{
    using System;
    using System.IO;
    using System.Net.Sockets;
    using SoftFX.Lrp.Implementation;

    /// <summary>
    /// Single threaded client.
    /// </summary>
    public class StClient : BaseClient
    {
        #region Construction

        /// <summary>
        /// Creates a new single-threaded client.
        /// </summary>
        /// <param name="localSignature">should be Signature.Value, where Signature is class generated by LRP generator.</param>
        /// <param name="address">address of remote LRP server.</param>
        /// <param name="port">port of remote LRP server.</param>
        /// <param name="username">an username</param>
        /// <param name="password">a password</param>
        public StClient(string localSignature, string address, Int32 port, string username, string password) : base(localSignature)
        {
            if (address == null)
                throw new ArgumentNullException("address", "Address of remote server can not be null");

            if (port <= 0)
                throw new ArgumentException("Port should be positive", "port");

            if (username == null)
                throw new ArgumentNullException("username", "Username can not be null");

            if (password == null)
                throw new ArgumentNullException("password", "Password can not be null");

            this.address = address;
            this.port = port;
            this.username = username;
            this.password = password;
            this.logger = new Logger(null);
        }

        /// <summary>
        /// Creates a new single-threaded client.
        /// </summary>
        /// <param name="localSignature">should be Signature.Value, where Signature is class generated by LRP generator.</param>
        /// <param name="address">address of remote LRP server.</param>
        /// <param name="port">port of remote LRP server.</param>
        /// <param name="username">an username</param>
        /// <param name="password">a password</param>
        /// <param name="logHandler">a single-threaded log handler; can not be null</param>
        public StClient(string localSignature, string address, Int32 port, string username, string password, LogHandler logHandler)
            : this(localSignature, address, port, username, password)
        {
            if (logHandler == null)
                throw new ArgumentNullException("logHandler", "Log handler can not be null");

            this.logger = new Logger(logHandler);
            this.logger.Output("Local signature = {0}", localSignature);
        }

        /// <summary>
        /// Creates a new single-threaded client.
        /// </summary>
        /// <param name="localSignature">should be Signature.Value, where Signature is class generated by LRP generator.</param>
        /// <param name="address">address of remote LRP server.</param>
        /// <param name="port">port of remote LRP server.</param>
        /// <param name="username">an username</param>
        /// <param name="password">a password</param>
        /// <param name="logPath">a relative or absolute path to log file</param>
        public StClient(string localSignature, string address, Int32 port, string username, string password, string logPath)
            : this(localSignature, address, port, username, password)
        {
            this.logStream = new StreamWriter(logPath);
            this.logger = new Logger(OnOutput);
            this.logger.Output("Local signature = {0}", localSignature);
        }

        #endregion

        #region Logging

        void OnOutput(string message)
        {
            try
            {
                var utcNow = DateTime.UtcNow;
                var prefix = utcNow.ToString("yyyy:MM:dd hh:mm:ss.fff");
                this.logStream.Write(prefix);
                this.logStream.Write(", ");
                this.logStream.Write(WinAPI.GetCurrentThreadId());
                this.logStream.Write(">: ");
                this.logStream.WriteLine(message);
                this.logStream.Flush();
            }
            catch
            {
                this.logger = new Logger(null);
            }
        }

        #endregion

        /// <summary>
        /// Returns true, if the client is connected.
        /// </summary>
        public bool IsConnected
        {
            get
            {
                return this.socket != null;
            }
        }
        /// <summary>
        /// 
        /// </summary>
        public int Timeout { get; set; }

        /// <summary>
        /// Connecting the single-threaded client to a remote server.
        /// </summary>
        /// <param name="timeoutInMilliseconds">Timeout of logical connection.</param>
        /// <returns>true, if connection has been established, otherwise false</returns>
        public bool Connect(int timeoutInMilliseconds)
        {
            if (this.socket != null)
            {
                this.logger.Output("Closing socket");
                this.socket.Close();
                this.socket = null;
                this.logger.Output("Socket has been closed");
            }

            this.logger.Output("Creating a new socket");
            var socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
            try
            {
                this.logger.Output("New socket has been created");
                this.logger.Output("Connectiong to {0}:{1}", this.address, this.port);
                socket.Connect(this.address, this.port);
                this.logger.Output("New connection has been established");
                this.logger.Output("Enabling keep alive");
                var keepalive = new TcpKeepalive(true, 10000, 3000);
                keepalive.Apply(socket);

                var timeout = new Timeout(timeoutInMilliseconds);

                this.logger.Output("Sending protocol version = {0}", ProtocolVersion.Initial);
                // send protocol version
                if (!Network.SendEx(socket.Handle, timeout, ProtocolVersion.Initial))
                {
                    this.logger.Output("Could not send protocol version");
                    return false;
                }
                this.logger.Output("Protocol version has been sent");
                int answer = HResult.S_OK;
                this.logger.Output("Receiving server protocol answer");
                if (!Network.ReceiveEx(socket.Handle, timeout, out answer))
                {
                    this.logger.Output("Could not receive server protocol answer");
                    return false;
                }
                this.logger.Output("Server protocol answer: code = {0}; status = {1}", answer, HResult.Succeeded(answer));
                if (HResult.Failed(answer))
                {
                    return false;
                }
                this.logger.Output("Sending username = {0}", this.username);
                if (!Network.SendEx(socket.Handle, timeout, this.username))
                {
                    this.logger.Output("Could not send username");
                    return false;
                }
                this.logger.Output("Username has been sent");
                this.logger.Output("Sending password = {0}", this.password);
                if (!Network.SendEx(socket.Handle, timeout, this.password))
                {
                    this.logger.Output("Could not send password");
                    return false;
                }
                this.logger.Output("Password has been sent");
                answer = HResult.S_OK;
                this.logger.Output("Receiving server authorization answer");
                if (!Network.ReceiveEx(socket.Handle, timeout, out answer))
                {
                    this.logger.Output("Could not receive server authorization answer");
                    return false;
                }
                this.logger.Output("Server authorization answer: code = {0}; status = {1}", answer, HResult.Succeeded(answer));
                if (HResult.Failed(answer))
                {
                    return false;
                }
                this.logger.Output("Receiving remote signature");
                string remoteSignature;
                if (!Network.ReceiveEx(socket.Handle, timeout, out remoteSignature))
                {
                    this.logger.Output("Could not receive remote signature");
                    return false;
                }
                this.logger.Output("Remote signature has been received = {0}", remoteSignature);
                this.logger.Output("Initializing translators");
                this.Initialize(remoteSignature);
                this.logger.Output("Translators have been initialized");
                this.socket = socket;
            }
            finally
            {
                if (this.socket != socket)
                {
                    socket.Close();
                }
            }
            this.FlushTranlators(this.logger);
            return true;
        }

        /// <summary>
        /// The methods tries to send an empty request and receive answer.
        /// The method closes the connection, if ping operation is failed; in this case you should connect the client again.
        /// </summary>
        /// <param name="timeoutInMilliseconds">Timeout in milliseconds for sending request and receiving response</param>
        /// <returns>
        /// true, if request has been sent and response has been received.
        /// false, if request has not been send or response has not been received or the client is disconnected.
        /// </returns>
        public bool Ping(int timeoutInMilliseconds)
        {
            if (this.socket == null)
                return false;

            using (var buffer = MemoryBuffer.CreateRemote(ushort.MaxValue, ushort.MaxValue))
            {
                try
                {
                    buffer.Position = 0;
                    buffer.WriteInt32(buffer.Size - sizeof(int));
                    var timeout = new Timeout(timeoutInMilliseconds);
                    this.Send(buffer, ref timeout);
                    this.Receive(buffer, ref timeout);
                    return true;
                }
                catch (TimeoutException)
                {
                    this.Dispose();
                    return false;
                }
                catch (DisconnectedException)
                {
                    this.Dispose();
                    return false;
                }
            }
        }

        #region IClient

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public override MemoryBuffer Create()
        {
            var result = MemoryBuffer.CreateRemote(0, 0);
            return result;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="componentId"></param>
        /// <param name="methodId"></param>
        /// <param name="data"></param>
        /// <returns></returns>
        public override int Invoke(ushort componentId, ushort methodId, MemoryBuffer data)
        {
            if (this.socket == null)
                throw new DisconnectedException();

            var size = data.Size;
            if (size < sizeof(Int32))
                throw new ArgumentException("Memory buffer is too small", "data");

            data.Position = 0;
            data.WriteInt32(size - 4);

            try
            {
                data.Position = 12;
                this.Translate(ref componentId, ref methodId);
                data.Position = 12;
                data.WriteUInt16(componentId);
                data.WriteUInt16(methodId);

                var timeout = new Timeout(this.Timeout);
                this.Send(data, ref timeout);
                this.Receive(data, ref timeout);
                data.Position = 12;
                int result = data.ReadInt32();
                return result;
            }
            catch
            {
                this.Dispose();
                throw;
            }
        }

        #endregion

        void SendText(string text, ref Timeout timeout)
        {
            using (var buffer = MemoryBuffer.CreateLocal())
            {
                buffer.WriteAString(text);
                this.Send(buffer, ref timeout);
            }
        }

        unsafe void Send(MemoryBuffer data, ref Timeout timeout)
        {
            var length = data.Size;
            var buffer = (Byte*)data.Data;
            var set = fd_set.Create(this.socket.Handle);

            for (; length > 0; )
            {
                var interval = timeout.ToTime();

                var status = WinAPI.select(1, null, &set, null, &interval);
                if (status == 0)
                    throw new TimeoutException("Timeout of sending has been reached.");

                status = WinAPI.send(this.socket.Handle, buffer, length, 0);
                if (status <= 0)
                    throw new DisconnectedException();

                buffer += status;
                length -= status;
            }
        }

        string ReciveText(ref Timeout timeout)
        {
            using (var buffer = MemoryBuffer.CreateLocal(4))
            {
                this.Receive(buffer, ref timeout);
                return buffer.ReadAString();
            }
        }

        unsafe void Receive(MemoryBuffer data, ref Timeout timeout)
        {
            data.Reset();
            var set = fd_set.Create(this.socket.Handle);
            var empty = fd_set.Null;

            // receiving package size and any additional data

            var length = data.Capacity;
            var buffer = (byte*)data.Data;

            var total = 0;
            for (; total < 4;)
            {
                var interval = timeout.ToTime();

                var status = WinAPI.select(1, &set, null, null, &interval);
                if (status == 0)
                    throw new TimeoutException("Timeout of receiving has been reached.");

                status = WinAPI.recv(this.socket.Handle, buffer, length, 0);
                if (status <= 0)
                    throw new DisconnectedException();

                buffer += status;
                total += status;
                length -= status;
            }
            data.Construct(total);
            var size = data.ReadInt32();
            data.Construct(sizeof(int) + size);

            length = size - total + sizeof(int); // remaining data length

            if (length < 0) // we read more than expected
                throw new DisconnectedException();

            if (length == 0) // we read all data
                return;

            buffer = (byte*)data.Data;
            buffer += total;
            for (; length > 0; )
            {
                var interval = timeout.ToTime();

                var status = WinAPI.select(1, &set, null, null, &interval);
                if (status == 0)
                    throw new TimeoutException("Timeout of receiving has been reached.");

                status = WinAPI.recv(this.socket.Handle, buffer, length, 0);
                if (status <= 0)
                    throw new DisconnectedException();

                buffer += status;
                length -= status;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public override void Dispose()
        {
            if (this.socket != null)
            {
                this.socket.Shutdown(SocketShutdown.Both);
                this.socket.Close();
                this.socket = null;
            }

            if (this.logStream != null)
            {
                this.logStream.Dispose();
                this.logStream = null;
            }
        }

        #region Input Arguments

        readonly string address;
        readonly int port;
        readonly string username;
        readonly string password;

        #endregion

        #region Fields

        Socket socket;
        StreamWriter logStream;
        Logger logger;

        #endregion
    }
}
